/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "roofit/RooExpAndGauss.h"
#include "RooAbsReal.h"
#include "RooRealVar.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(RooExpAndGauss)


  RooExpAndGauss::RooExpAndGauss()
  {
   RooRealVar xRV("xRV","x", 0.0, 1.0);
   RooRealVar sh_meanRV("sh_meanRV", "sh_mean", 0.0, 1.0);
   RooRealVar sh_sigmaRV("sh_sigmaRV","sh_sigma", 0.0, 1.0);
   RooRealVar sh_transRV("sh_transRV","sh_trans", 0.0, 1.0);

   RooExpAndGauss("RooExpAndGauss", "RooExpAndGauss", xRV, sh_meanRV, sh_sigmaRV, sh_transRV);
 }

 RooExpAndGauss::RooExpAndGauss(const char *name, const char *title,
                        RooAbsReal& _x,
                        RooAbsReal& _mbar,
                        RooAbsReal& _thresh,
                        RooAbsReal& _k) :
   RooAbsPdf(name,title),
   x("x","x",this,_x),
   mbar("mbar","mbar",this,_mbar),
   thresh("thresh","thresh",this,_thresh),
   k("k","k",this,_k)
 {
 }


 RooExpAndGauss::RooExpAndGauss(const RooExpAndGauss& other, const char* name) :
   RooAbsPdf(other,name),
   x("x",this,other.x),
   mbar("mbar",this,other.mbar),
   thresh("thresh",this,other.thresh),
   k("k",this,other.k)
 {
 }


// Int_t RooExpAndGauss::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analvars, const char* ) const
// {
//   if (matchArgs(allVars, analvars, x)) return 1;
//   return 0;
// }

// Double_t RooExpAndGauss::analyticalIntegral(int code, const char* rangeName) const
// {
//   assert(code ==1);
//   static const double root2 = 1.0/sqrt(2.);
//   static const double rootPiBy2 = sqrt(atan2(0.0,-1.0)/2.0);
//   double beta = (mbar - thresh)/(k*k);
//   double lnc = -0.5*pow((thresh-mbar)/k,2)-beta*thresh;
//   double c = exp(lnc);
//   Double_t ret=0;
//   Double_t gaussint=0;
//   Double_t expint=0;
//   if (code == 1)
//   {
//     if (thresh > x.max(rangeName))
//     {
//     gaussint = 0;
//     expint = (c/beta)*(exp(x.max(rangeName)*beta)-exp(x.min(rangeName)*beta));
//     }
//     else if (thresh < x.min(rangeName))
//     {
//     gaussint = k*rootPiBy2*(RooMath::erf(root2*(mbar-x.min(rangeName))/k)-RooMath::erf(root2*(mbar-x.max(rangeName))/k));
//     expint = 0;
//     }
//     else
//     {
//     gaussint = k*rootPiBy2*(RooMath::erf(root2*(mbar-thresh)/k)-RooMath::erf(root2*(mbar-x.max(rangeName))/k));
//     expint = (c/beta)*(exp(thresh*beta)-exp(x.min(rangeName)*beta));
//     }
//   }
//   ret = gaussint + expint;
//   std::cout << "rootPiBy2 " << rootPiBy2 << std::endl;
//   std::cout << "RooMath::erf(root2*(mbar-thresh)/k) " << RooMath::erf(root2*(mbar-thresh)/k) << " RooMath::erf(root2*(mbar-x.max(rangeName))/k) " << RooMath::erf(root2*(mbar-x.max(rangeName))/k) << std::endl;
//   std::cout << "thresh " << thresh << "min " << x.min(rangeName) << " max " << x.max(rangeName) << std::endl;
//   std::cout << "ret " << ret << " gaussint " << gaussint << " expint " << expint << std::endl;
//   return ret;
// }


 Double_t RooExpAndGauss::evaluate() const
 {
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE
   double beta = (mbar - thresh)/(k*k);
 double c = exp(-0.5*pow((thresh-mbar)/k,2))*exp(-beta*thresh);
 if (x <= thresh){
    return c*exp(beta*x);
 }
 //exp(-0.5*(((thresh-mbar)/k)*((thresh-mbar)/k))+(((mbar-thresh)*(x-thresh))/(k*k)))

 return exp(-0.5*pow((x-mbar)/k,2));
 }



